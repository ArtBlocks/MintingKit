//
// Minting.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Minting: Codable, JSONEncodable, Hashable {

    public var id: String?
    /** The time at which the transaction was initiated by the connected Ethereum node. */
    public var startedAt: Date?
    /** The time at which the transaction first appeared in a mined block. */
    public var minedAt: Date?
    /** The first block in which the transaction was visible. */
    public var blockNumber: Int?
    /** The number of subsequent blocks (if available) that include the minting transaction. */
    public var blockConfirmations: Int?
    /** The transaction hash for the Project's minting contract. */
    public var transactionHash: String?
    /** The hashed checksum public address of the destination wallet. */
    public var destinationWallet: String?
    /** The Project being minted. */
    public var project: String?
    /** The integer ID of the token that was minted by the PBAB contract. */
    public var tokenId: Int?
    /** The metadata for the token retrieved from the Art Blocks API. */
    public var metadata: AnyCodable?
    /** The full URL of the embeddable live view of the minted art. */
    public var embedUrl: String?
    public var receipt: MintingReceipt?

    public init(id: String? = nil, startedAt: Date? = nil, minedAt: Date? = nil, blockNumber: Int? = nil, blockConfirmations: Int? = nil, transactionHash: String? = nil, destinationWallet: String? = nil, project: String? = nil, tokenId: Int? = nil, metadata: AnyCodable? = nil, embedUrl: String? = nil, receipt: MintingReceipt? = nil) {
        self.id = id
        self.startedAt = startedAt
        self.minedAt = minedAt
        self.blockNumber = blockNumber
        self.blockConfirmations = blockConfirmations
        self.transactionHash = transactionHash
        self.destinationWallet = destinationWallet
        self.project = project
        self.tokenId = tokenId
        self.metadata = metadata
        self.embedUrl = embedUrl
        self.receipt = receipt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case startedAt = "started_at"
        case minedAt = "mined_at"
        case blockNumber = "block_number"
        case blockConfirmations = "block_confirmations"
        case transactionHash = "transaction_hash"
        case destinationWallet = "destination_wallet"
        case project
        case tokenId = "token_id"
        case metadata
        case embedUrl = "embed_url"
        case receipt
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(startedAt, forKey: .startedAt)
        try container.encodeIfPresent(minedAt, forKey: .minedAt)
        try container.encodeIfPresent(blockNumber, forKey: .blockNumber)
        try container.encodeIfPresent(blockConfirmations, forKey: .blockConfirmations)
        try container.encodeIfPresent(transactionHash, forKey: .transactionHash)
        try container.encodeIfPresent(destinationWallet, forKey: .destinationWallet)
        try container.encodeIfPresent(project, forKey: .project)
        try container.encodeIfPresent(tokenId, forKey: .tokenId)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encodeIfPresent(embedUrl, forKey: .embedUrl)
        try container.encodeIfPresent(receipt, forKey: .receipt)
    }
}

